/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package report;

import com.toedter.calendar.JDateChooser;
import entity.Arti;
import entity.Best;
import general.Print;
import gui.WaWiMainGUI;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import javax.swing.table.DefaultTableModel;

/**
 *
 * @author Markus
 */
// Klasse ReportMainGUI
// Enthält Methoden zum Erstellen von Reports.
// Die Reports sollen nützliche Informatioen für u. a. die Geschäftsführung
// bereitstellen
public class ReportMainGUI extends javax.swing.JFrame {

    // Klassenvariablen
    List result;
    List result2;
    List result3;
    Iterator iterator;
    Iterator iterator2;
    Iterator iterator3;
    DefaultTableModel model;
    SimpleDateFormat dateFormat;
    Boolean Volumenauswahl;

    /**
     * Creates new form ReportGUI
     */
    // Konstruktor der Klasse ReportMainGUI;
    public ReportMainGUI() {
        initComponents();
        this.model = (DefaultTableModel) tableAusgabe.getModel();
        this.dateFormat = new SimpleDateFormat("dd-MM-yyyy");
        this.Volumenauswahl = false;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        labelReports = new javax.swing.JLabel();
        buttonBack = new javax.swing.JButton();
        buttonShowArticlelist = new javax.swing.JButton();
        buttonShowOpenOrders = new javax.swing.JButton();
        buttonShowOrders = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        tableAusgabe = new javax.swing.JTable();
        buttonShowCritStock = new javax.swing.JButton();
        buttonBestSelling = new javax.swing.JButton();
        buttonWorstSelling = new javax.swing.JButton();
        buttonPrint = new javax.swing.JButton();
        jDateChooserVon = new com.toedter.calendar.JDateChooser();
        jDateChooserBis = new com.toedter.calendar.JDateChooser();
        jLabelVon = new javax.swing.JLabel();
        jLabelBis = new javax.swing.JLabel();
        jButtonVolumenOK = new javax.swing.JButton();
        buttonCancelVolumen = new javax.swing.JButton();
        buttonVolumenCustomer = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        labelReports.setText("Reports");

        buttonBack.setText("Zurück");
        buttonBack.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        buttonBack.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonBackActionPerformed(evt);
            }
        });

        buttonShowArticlelist.setText("Artikel und Bestände");
        buttonShowArticlelist.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        buttonShowArticlelist.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonShowArticlelistActionPerformed(evt);
            }
        });

        buttonShowOpenOrders.setText("Offene Bestellungen");
        buttonShowOpenOrders.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        buttonShowOpenOrders.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonShowOpenOrdersActionPerformed(evt);
            }
        });

        buttonShowOrders.setText("Bestellvolumen insg.");
        buttonShowOrders.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        buttonShowOrders.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonShowOrdersActionPerformed(evt);
            }
        });

        tableAusgabe.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {

            }
        ));
        jScrollPane1.setViewportView(tableAusgabe);

        buttonShowCritStock.setText("Kritische Bestandsmengen");
        buttonShowCritStock.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        buttonShowCritStock.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonShowCritStockActionPerformed(evt);
            }
        });

        buttonBestSelling.setText("Meistverkaufte Artikel");
        buttonBestSelling.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        buttonBestSelling.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonBestSellingActionPerformed(evt);
            }
        });

        buttonWorstSelling.setText("Schlechtverkaufteste Artikel");
        buttonWorstSelling.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        buttonWorstSelling.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonWorstSellingActionPerformed(evt);
            }
        });

        buttonPrint.setText("Drucken");
        buttonPrint.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        buttonPrint.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonPrintActionPerformed(evt);
            }
        });

        jDateChooserVon.setEnabled(false);

        jDateChooserBis.setEnabled(false);

        jLabelVon.setText("Von:");
        jLabelVon.setEnabled(false);

        jLabelBis.setText("Bis:");
        jLabelBis.setEnabled(false);

        jButtonVolumenOK.setText("OK");
        jButtonVolumenOK.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        jButtonVolumenOK.setEnabled(false);
        jButtonVolumenOK.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonVolumenOKActionPerformed(evt);
            }
        });

        buttonCancelVolumen.setText("Abbrechen");
        buttonCancelVolumen.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        buttonCancelVolumen.setEnabled(false);
        buttonCancelVolumen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonCancelVolumenActionPerformed(evt);
            }
        });

        buttonVolumenCustomer.setText("Bestellvolumen nach Kunde");
        buttonVolumenCustomer.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonVolumenCustomerActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addGroup(layout.createSequentialGroup()
                                    .addComponent(buttonBack)
                                    .addGap(54, 54, 54)
                                    .addComponent(labelReports))
                                .addComponent(buttonWorstSelling, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(buttonShowArticlelist, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(buttonShowCritStock, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(buttonShowOpenOrders, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(buttonBestSelling, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(buttonPrint, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(26, 26, 26)
                                .addComponent(buttonCancelVolumen)
                                .addGap(18, 18, 18)
                                .addComponent(jButtonVolumenOK))
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                .addComponent(buttonVolumenCustomer, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 167, Short.MAX_VALUE)
                                .addComponent(buttonShowOrders, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 55, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabelVon)
                            .addComponent(jLabelBis))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jDateChooserVon, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jDateChooserBis, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 474, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(buttonBack)
                            .addComponent(labelReports))
                        .addGap(26, 26, 26)
                        .addComponent(buttonShowArticlelist)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(buttonShowCritStock)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(buttonShowOpenOrders)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(buttonBestSelling)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(buttonWorstSelling)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(buttonVolumenCustomer)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 11, Short.MAX_VALUE)
                        .addComponent(buttonShowOrders)
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jDateChooserVon, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabelVon, javax.swing.GroupLayout.PREFERRED_SIZE, 14, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabelBis)
                            .addComponent(jDateChooserBis, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(buttonCancelVolumen)
                            .addComponent(jButtonVolumenOK))
                        .addGap(18, 18, 18)
                        .addComponent(buttonPrint, javax.swing.GroupLayout.PREFERRED_SIZE, 56, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(39, 39, 39))
        );

        labelReports.getAccessibleContext().setAccessibleName("labelReports");
        buttonBack.getAccessibleContext().setAccessibleName("buttonBack");
        buttonShowArticlelist.getAccessibleContext().setAccessibleName("buttonShowArtikelliste");
        buttonShowOpenOrders.getAccessibleContext().setAccessibleName("buttonBestellungen");
        buttonShowOrders.getAccessibleContext().setAccessibleName("buttonShowBestellvolumen");

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents

    // Methode buttonBackActionPerformed
    // Bei Klick auf den "Zurück-Button" wird die aktuelle Ansicht ausgeblendet
    // und Hauptmenü des Warenwirtschaftssystem eingeblendet.
    // Übergabeparameter: Button Clickevent
    private void buttonBackActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonBackActionPerformed
        setVisible(false);
        // Objekt der Klasse WaWiMainGUI erzeugen
        WaWiMainGUI wawiGUI = new WaWiMainGUI();
        wawiGUI.setVisible(true);
    }//GEN-LAST:event_buttonBackActionPerformed

    //Methode buttonShowArticlelistActionPerformed
    //Bei Klick auf den "Artikel und Bestände"-Button wird diese
    //Methode zum Anzeigen einer Artikelliste mit aktueller Bestandsmenge aufgerufen.
    //Dazu werden die Spaltennamen der Ausgabetabelle dementsprechend gesetzt
    //und die nötigen SQL-Abfragen zur Ermittlung aller Artikel ausgeführt.
    //Das Ergebnis der Abfrage wird Zeile für Zeile in der Ausgabetabelle
    //aufgeführt.
    //Übergabeparameter: Button-Clickevent
    private void buttonShowArticlelistActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonShowArticlelistActionPerformed
        // Spaltennamen der Tabelle
        String[] columnnames = {"Artikelnummer ", "Bezeichnung", "Bestandsmenge","Krit. Bestand"};
        // Methode zum Setzen der Spaltennamen der Tabelle aufrufen
        setColumnnames(columnnames);
        // Aufruf der Methode Connect; Übergabe des SQL-Statements an die Methode
        // RÜckgabewerte der Methode wird result zugewiesen
        result = connect("From Arti WHERE LOESCHKENNZEICHEN = ' ' order by ANR asc");

        Object rowData[] = new Object[4];

        // result enthält Ergebnisse der SQL-Abfrage
        // diese Ergebnisse werden nun Zeile für Zeile ausgegeben bis keine
        // weiteren in der Liste(result) vorhanden sind)
        for (iterator = result.iterator(); iterator.hasNext();) {
            // Bei den einzelnen Ergebnissen handelt es sich um Artikel
            // Casten auf Arti
            Arti Artikel = (Arti) iterator.next();
            rowData[0] = Artikel.getANR();
            rowData[1] = Artikel.getBEZEICHNUNG();
            rowData[2] = Artikel.getBESTANDSMENGE();
            rowData[3] = Artikel.getKrit_Menge();
            // Zeile der Tabelle hinzufügen
            model.addRow(rowData);
        }
    }//GEN-LAST:event_buttonShowArticlelistActionPerformed

    // Methode Connect
    // Methode zum Herstellen der Datenbankverbindung und Auführen der SQL-
    // Statements
    // Übergabeparameter: String statement
    // statement: SQL-Statement, welches ausgeführt werden soll
    // Rückgabewert: List
    // Gibt das Ergebnis der SQL-Abfrage als List zurück
    private List connect(String statement) {
        database.DB_Connect con = new database.DB_Connect();
        return con.Connect(statement);
    }

    // Methode setColumnnames
    // Setzt die Spaltennamen der Tabelle auf die übergebenen Namen
    // und setzt den Zeilenzähler auf 0 (keine Zeilen vorhanden)
    // Übergabeparameter: String[] names
    // names: Stringarray mit Spaltennamen
    private void setColumnnames(String[] names) {
        model = (DefaultTableModel) tableAusgabe.getModel();
        model.setColumnIdentifiers(names);
        model.setRowCount(0);
    }

    //Methode buttonShowOpenOrdersActionPerformed
    //Bei Klick auf den "Offene Bestellungen"-Button wird diese 
    //Methode zum Anzeigen aller offenen Bestellungen aufgerufen.
    //Dazu werden die Spaltennamen der Ausgabetabelle dementsprechend gesetzt
    //und die nötigen SQL-Abfragen zur Ermittlung aller offenen Bestellungen ausgeführt.
    //Das Ergebnis der Abfrage wird Zeile für Zeile in der Ausgabetabelle
    //aufgeführt.
    //Übergabeparameter: Button-Clickevent
    private void buttonShowOpenOrdersActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonShowOpenOrdersActionPerformed
        // Spaltennamen der Tabelle
        String[] columnnames = {"BNR ", "BESTELLDATUM", "STATUS"};
        // Methode zum Setzen der Spaltennamen der Tabelle aufrufen
        setColumnnames(columnnames);
        // Aufruf der Methode Connect; Übergabe des SQL-Statements an die Methode
        // Rückgabewerte der Methode wird result zugewiesen
        result = connect("FROM Best where status = 'offen' order by BNR");
        Object rowData[] = new Object[3];
        // result enthält Ergebnisse der SQL-Abfrage
        // diese Ergebnisse werden nun Zeile für Zeile ausgegeben bis keine
        // weiteren in der Liste(result) vorhanden sind)
        for (iterator = result.iterator(); iterator.hasNext();) {
            Best Bestellung = (Best) iterator.next();

            rowData[0] = Bestellung.getBNR();
            rowData[1] = Bestellung.getBESTELLDATUM();
            rowData[2] = Bestellung.getSTATUS();
            // Zeile der Tabelle hinzufügen
            model.addRow(rowData);
        }
    }//GEN-LAST:event_buttonShowOpenOrdersActionPerformed

    // Methode buttonShowOrdersActionPerformed
    // Bei Klick auf den "Bestellvolumen insg."-Button wird diese Methode 
    // zum Deaktivieren/Aktivieren aller nicht benötigten und
    // benötigten Steuerelemente aufgerufen.
    // Die Variable Volumenauswahl wird true gesetzt. Das heißt, dass das Gesamt-
    // volumen berechnet werden soll (über alle Kunden und Artikel)
    // Übergabeparameter: Button Clickevent
    private void buttonShowOrdersActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonShowOrdersActionPerformed
        // true: Das Gesamtvolumen soll berechnet werden(Über alle Kunden und Artikel)
        this.Volumenauswahl = true;

        buttonBack.setEnabled(false);
        buttonShowArticlelist.setEnabled(false);
        buttonShowCritStock.setEnabled(false);
        buttonShowOpenOrders.setEnabled(false);
        buttonBestSelling.setEnabled(false);
        buttonWorstSelling.setEnabled(false);
        buttonVolumenCustomer.setEnabled(false);

        jLabelVon.setEnabled(true);
        jLabelBis.setEnabled(true);
        jDateChooserVon.setEnabled(true);
        jDateChooserBis.setEnabled(true);
        jButtonVolumenOK.setEnabled(true);
        buttonCancelVolumen.setEnabled(true);

        this.setDefaultDates(jDateChooserVon, jDateChooserBis);
    }//GEN-LAST:event_buttonShowOrdersActionPerformed

    //Methode buttonShowCritStockActionPerformed
    //Bei Klick auf den "Kritische Bestandsmengen"-Button wird diese
    //Methode zum Anzeigen aller Artikel, bei welchen eine kritische Bestandsmenge
    //vorliegt, aufgerufen.
    //Dazu werden die Spaltennamen der Ausgabetabelle dementsprechend gesetzt
    //und die nötigen SQL-Abfragen zur Ermittlung aller Artikel ausgeführt.
    //Das Ergebnis der Abfrage wird Zeile für Zeile in der Ausgabetabelle
    //aufgeführt.
    //Übergabeparameter: Button-Clickevent
    private void buttonShowCritStockActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonShowCritStockActionPerformed
        // Spaltennamen der Tabelle
        String[] columnnames = {"Artikelnummer ", "Bezeichnung", "Bestandsmenge", "Krit. Menge"};
        // Methode zum Setzen der Spaltennamen der Tabelle aufrufen
        setColumnnames(columnnames);
        // Aufruf der Methode Connect; Übergabe des SQL-Statements an die Methode
        // RÜckgabewerte der Methode wird result zugewiesen
        result = connect("From Arti WHERE LOESCHKENNZEICHEN = ' ' AND BESTANDSMENGE <= KRIT_MENGE");

        Object rowData[] = new Object[4];
        // result enthält Ergebnisse der SQL-Abfrage
        // diese Ergebnisse werden nun Zeile für Zeile ausgegeben bis keine
        // weiteren in der Liste(result) vorhanden sind)
        for (iterator = result.iterator(); iterator.hasNext();) {
            Arti Artikel = (Arti) iterator.next();
            rowData[0] = Artikel.getANR();
            rowData[1] = Artikel.getBEZEICHNUNG();
            rowData[2] = Artikel.getBESTANDSMENGE();
            rowData[3] = Artikel.getKrit_Menge();
            // Zeile der Tabelle hinzufügen
            model.addRow(rowData);
        }
    }//GEN-LAST:event_buttonShowCritStockActionPerformed

    //Methode buttonBestSellingActionPerformed
    //Bei Klick auf den "Meistverkaufte Artikel"-Button wird diese
    //Methode zum Anzeigen aller Artikel mit verkauften Menge
    // , absteigend sortiert nach Menge der Verkäufe, aufgerufen.
    //Dazu werden die Spaltennamen der Ausgabetabelle dementsprechend gesetzt
    //und die nötigen SQL-Abfragen zur Ermittlung aller Artikel ausgeführt.
    //Das Ergebnis der Abfrage wird Zeile für Zeile in der Ausgabetabelle
    //aufgeführt.
    //Übergabeparameter: Button-Clickevent
    private void buttonBestSellingActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonBestSellingActionPerformed
        // Spaltennamen der Tabelle
        String[] columnnames = {"Artikelnummer ", "Bezeichnung", "Menge"};
        // Methode zum Setzen der Spaltennamen der Tabelle aufrufen
        setColumnnames(columnnames);
        // Aufruf der Methode Connect; Übergabe des SQL-Statements an die Methode
        // RÜckgabewerte der Methode wird result zugewiesen
        result = connect("select sum(ANZAHL) as summe from K_BA WHERE best.STATUS = 'Abgeschlossen' group by arti order by summe desc");
        // Aufruf der Methode Connect; Übergabe des SQL-Statements an die Methode
        // RÜckgabewerte der Methode wird result2 zugewiesen
        result2 = connect("select arti.ANR from K_BA WHERE best.STATUS = 'Abgeschlossen' group by arti order by sum(ANZAHL) desc");

        Object rowData[] = new Object[3];

        iterator = result.iterator();
        // result enthält Ergebnisse der SQL-Abfrage
        // diese Ergebnisse werden nun Zeile für Zeile ausgegeben bis keine
        // weiteren in der Liste(result2) vorhanden sind)
        for (iterator2 = result2.iterator(); iterator2.hasNext();) {
            int artikel = (int) iterator2.next();
            rowData[0] = artikel;

            long sumArtikel = (long) iterator.next();
            rowData[2] = sumArtikel;
            // Zeile der Tabelle hinzufügen
            model.addRow(rowData);
        }
        for (int i = 0; i < model.getRowCount(); i++) {
            int anr = Integer.parseInt(model.getValueAt(i, 0).toString());
            // Aufruf der Methode Connect; Übergabe des SQL-Statements an die Methode
            // RÜckgabewerte der Methode wird result zugewiesen
            result = connect("select BEZEICHNUNG from Arti Where ANR= " + anr);
            // result enthält Ergebnisse der SQL-Abfrage
            // diese Ergebnisse werden nun Zeile für Zeile ausgegeben bis keine
            // weiteren in der Liste(result) vorhanden sind)
            for (iterator2 = result.iterator(); iterator2.hasNext();) {
                model.setValueAt(iterator2.next(), i, 1);
            }
        }
    }//GEN-LAST:event_buttonBestSellingActionPerformed
    //Methode buttonWorstSellingActionPerformed
    //Bei Klick auf den "Schlechtverkaufteste Artikel"-Button wird diese
    //Methode zum Anzeigen aller Artikel mit verkauften Menge
    // , aufsteigend sortiert nach Menge der Verkäufe, aufgerufen.
    //Dazu werden die Spaltennamen der Ausgabetabelle dementsprechend gesetzt
    //und die nötigen SQL-Abfragen zur Ermittlung aller Artikel ausgeführt.
    //Das Ergebnis der Abfrage wird Zeile für Zeile in der Ausgabetabelle
    //aufgeführt.
    //Übergabeparameter: Button-Clickevent
    private void buttonWorstSellingActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonWorstSellingActionPerformed
        // Spaltennamen der Tabelle
        String[] columnnames = {"Artikelnummer ", "Bezeichnung", "Menge"};
        // Methode zum Setzen der Spaltennamen der Tabelle aufrufen
        setColumnnames(columnnames);
        // Aufruf der Methode Connect; Übergabe des SQL-Statements an die Methode
        // RÜckgabewerte der Methode wird result zugewiesen
        result = connect("select sum(ANZAHL) as summe from K_BA WHERE best.STATUS = 'Abgeschlossen' group by arti order by summe asc");
        // Aufruf der Methode Connect; Übergabe des SQL-Statements an die Methode
        // RÜckgabewerte der Methode wird result2 zugewiesen
        result2 = connect("select arti.ANR from K_BA WHERE best.STATUS = 'Abgeschlossen' group by arti order by sum(ANZAHL) asc");

        Object rowData[] = new Object[3];
        iterator = result.iterator();
        // result enthält Ergebnisse der SQL-Abfrage
        // diese Ergebnisse werden nun Zeile für Zeile ausgegeben bis keine
        // weiteren in der Liste(result2) vorhanden sind)
        for (iterator2 = result2.iterator(); iterator2.hasNext();) {
            int artikel = (int) iterator2.next();
            rowData[0] = artikel;

            long sumArtikel = (long) iterator.next();
            rowData[2] = sumArtikel;
            // Zeile der Tabelle hinzufügenr
            model.addRow(rowData);
        }
        for (int i = 0; i < model.getRowCount(); i++) {

            int anr = Integer.parseInt(model.getValueAt(i, 0).toString());
            // Aufruf der Methode Connect; Übergabe des SQL-Statements an die Methode
            // RÜckgabewerte der Methode wird result zugewiesen
            result = connect("select BEZEICHNUNG from Arti Where ANR= " + anr);
            // result enthält Ergebnisse der SQL-Abfrage
            // diese Ergebnisse werden nun Zeile für Zeile ausgegeben bis keine
            // weiteren in der Liste(result) vorhanden sind)
            for (iterator2 = result.iterator(); iterator2.hasNext();) {
                model.setValueAt(iterator2.next(), i, 1);
            }
        }
    }//GEN-LAST:event_buttonWorstSellingActionPerformed

    // Methode buttonPrintActionPerformed
    // Bei Betätigung des "Drucken"-Buttons wird überprüft, ob Daten in der Tabelle
    // vorhanden sind.
    // Falls ja: Methode CreatePages ausführen
    // Falls nein: Hinweis an den Anwender
    // Übergabeparameter: Button-Clickevent
    private void buttonPrintActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonPrintActionPerformed
        // Objekt der Klasse Print erzeugen
        Print drucken = new Print("Report");
        // Falls in der Tabelle mindestens 1 Zeile steht, wird die CreatePages-
        // Methode des Objektes drucken ausgeführt
        if (tableAusgabe.getColumnCount() > 0) {
            drucken.CreatePages(tableAusgabe);
            // Sollte keine Zeilen in der Tabelle vorhanden sein, erhält der Anwender einen
            // Hinweis
        } else {
            // Methode ShowError aufrufen um eine Error-Messagebox anzuzeigen
            general.Message.showError("", "Keine Daten!\nBitte Report auswählen.");
        }
    }//GEN-LAST:event_buttonPrintActionPerformed
    //Methode jButtonVolumenOKActionPerformed
    //Bei Klick auf den "OK"-Button wird diese
    //Methode ausgerufen. Das eingegebene Datum wird formatiert und je nachdem
    //welches VOlumen ausgewählt wurde, wird die Methode ermittleBestellvolumen oder
    //die Methode ermittleBestellvolumenKunden aufgerufen.
    //Nicht mehr benötige Buttons werden deaktiviert und benötigte aktiviert
    //Übergabeparameter: Button-Clickevent
    private void jButtonVolumenOKActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonVolumenOKActionPerformed
        // Eingebenes Datum formatieren
        String von = dateFormat.format(jDateChooserVon.getDate());
        String bis = dateFormat.format(jDateChooserBis.getDate());
        // Wenn Gesamtes Bestellvolumen ermittelt werden soll
        if (this.Volumenauswahl == true) {
            ermittleBestellvolumen(von, bis);
        } // Wenn das Bestellvolumen nach Kunden ermittelt werden soll
        else {
            ermittleBestellvolumenKunden(von, bis);
        }
        //Buttons die nun wieder verfügbar sein sollen für den Anwender
        //werden aktiviert
        buttonBack.setEnabled(true);
        buttonShowArticlelist.setEnabled(true);
        buttonShowCritStock.setEnabled(true);
        buttonShowOpenOrders.setEnabled(true);
        buttonBestSelling.setEnabled(true);
        buttonWorstSelling.setEnabled(true);
        buttonShowOrders.setEnabled(true);
        buttonVolumenCustomer.setEnabled(true);
        //Buttons die nicht mehr verfügbar sein sollen für den Anwender
        //werden deaktiviert
        buttonCancelVolumen.setEnabled(false);
        jLabelVon.setEnabled(false);
        jLabelBis.setEnabled(false);
        jDateChooserVon.setEnabled(false);
        jDateChooserBis.setEnabled(false);
        jButtonVolumenOK.setEnabled(false);

    }//GEN-LAST:event_jButtonVolumenOKActionPerformed

    // Methode buttonCancelVolumenActionPerformed
    // Sollte die Auswahl die Zeitraum für die Bestellvolumen-Reports abgebrochen werden,
    // werden die nicht mehr benötigte Steuerelemente(für die Zeitraumsauswahl) deaktiviert
    // und die Steuerelemente für die anderen Reports aktiviert
    // Übergabeparameter: Button Clickevent
    private void buttonCancelVolumenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonCancelVolumenActionPerformed
        buttonBack.setEnabled(true);
        buttonShowArticlelist.setEnabled(true);
        buttonShowCritStock.setEnabled(true);
        buttonShowOpenOrders.setEnabled(true);
        buttonBestSelling.setEnabled(true);
        buttonWorstSelling.setEnabled(true);
        buttonShowOrders.setEnabled(true);
        buttonVolumenCustomer.setEnabled(true);

        buttonCancelVolumen.setEnabled(false);
        jLabelVon.setEnabled(false);
        jLabelBis.setEnabled(false);
        jDateChooserVon.setEnabled(false);
        jDateChooserBis.setEnabled(false);
        jButtonVolumenOK.setEnabled(false);
    }//GEN-LAST:event_buttonCancelVolumenActionPerformed

    // Methode buttonVolumenCustomerActionPerformed
    // Methode zum Deaktivieren/Aktivieren aller nicht benötigter und
    // benötigter Steuerelemente
    // Die Variable Volumenauswahl wird false gesetzt. Das heißt, dass das 
    // Bestellvolumen gruppiert ausgegeben werden soll.
    private void buttonVolumenCustomerActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonVolumenCustomerActionPerformed
        this.Volumenauswahl = false;

        buttonBack.setEnabled(false);
        buttonShowArticlelist.setEnabled(false);
        buttonShowCritStock.setEnabled(false);
        buttonShowOpenOrders.setEnabled(false);
        buttonBestSelling.setEnabled(false);
        buttonWorstSelling.setEnabled(false);
        buttonShowOrders.setEnabled(false);

        jLabelVon.setEnabled(true);
        jLabelBis.setEnabled(true);
        jDateChooserVon.setEnabled(true);
        jDateChooserBis.setEnabled(true);
        jButtonVolumenOK.setEnabled(true);
        buttonCancelVolumen.setEnabled(true);

        this.setDefaultDates(jDateChooserVon, jDateChooserBis);
    }//GEN-LAST:event_buttonVolumenCustomerActionPerformed
    //Methode ermittleBestellvolumen 
    //Methode zum Anzeigen/Ermitteln des Bestellvolumens(€ und Menge)über einen
    //eingebenen Zeitraum.
    //Dazu werden die Spaltennamen der Ausgabetabelle dementsprechend gesetzt
    //und die nötigen SQL-Abfragen zur Ermittlung des Bestellvolumens ausgeführt.
    //Das Ergebnis der Abfrage wird Zeile für Zeile in der Ausgabetabelle
    //aufgeführt.
    //Übergabeparameter: String von, String bis
    //von: Datum; Beginn des Zeitraums
    //bis: Datum; Ende des Zeitraums
    private void ermittleBestellvolumen(String von, String bis) {
        // Spaltennamen der Tabelle
        String[] columnnames = {"Verkaufte Menge ", "Warenwert € gesamt"};
        // Methode zum Setzen der Spaltennamen der Tabelle aufrufen
        setColumnnames(columnnames);
        // Aufruf der Methode Connect; Übergabe des SQL-Statements an die Methode
        // RÜckgabewerte der Methode wird result zugewiesen
        result = connect("select sum(ANZAHL) from K_BA WHERE best.BESTELLDATUM between '" + von + "' and '" + bis + "'");
        // Aufruf der Methode Connect; Übergabe des SQL-Statements an die Methode
        // RÜckgabewerte der Methode wird result2 zugewiesen
        result2 = connect("select sum(arti.VK_Preis*ANZAHL) from K_BA WHERE best.BESTELLDATUM between '" + von + "' and '" + bis + "'");

        Object rowData[] = new Object[2];
        iterator2 = result2.iterator();
        // result enthält Ergebnisse der SQL-Abfrage
        // diese Ergebnisse werden nun Zeile für Zeile ausgegeben bis keine
        // weiteren in der Liste(result) vorhanden sind)
        for (iterator = result.iterator(); iterator.hasNext();) {
            long BNR = (long) iterator.next();
            rowData[0] = BNR;

            double SumEuro = (double) iterator2.next();
            rowData[1] = SumEuro;
            // Zeile der Tabelle hinzufügen
            model.addRow(rowData);
        }
    }

    //Methode ermittleBestellvolumenKunden 
    //Methode zum Anzeigen/Ermitteln des Bestellvolumens(€ und Menge)über einen
    //eingebenen Zeitraum. Dies wird nach den Kunden gruppiert, sodass ersichtlich
    //wird, welcher Kunde welche Menge abgenommen und für wie viel Umsatz dieser 
    //gesorgt hat.
    //Dazu werden die Spaltennamen der Ausgabetabelle dementsprechend gesetzt
    //und die nötigen SQL-Abfragen zur Ermittlung des Bestellvolumens ausgeführt.
    //Das Ergebnis der Abfrage wird Zeile für Zeile in der Ausgabetabelle
    //aufgeführt.
    //Übergabeparameter: String von, String bis
    //von: Datum; Beginn des Zeitraums
    //bis: Datum; Ende des Zeitraums
    private void ermittleBestellvolumenKunden(String von, String bis) {
        // Spaltennamen der Tabelle
        String[] columnnames = {"Kundennummer", "Verkaufte Menge ", "Warenwert € gesamt"};
        // Methode zum Setzen der Spaltennamen der Tabelle aufrufen
        setColumnnames(columnnames);
        // Aufruf der Methode Connect; Übergabe des SQL-Statements an die Methode
        // RÜckgabewerte der Methode wird result zugewiesen
        result = connect("select sum(ANZAHL) from K_BA WHERE best.BESTELLDATUM between"
                + " '" + von + "' and '" + bis + "' "
                + "group by best.kund.KNr order by best.kund.KNr asc");
        // Aufruf der Methode Connect; Übergabe des SQL-Statements an die Methode
        // RÜckgabewerte der Methode wird result2 zugewiesen
        result2 = connect("select sum(arti.VK_Preis*ANZAHL) from K_BA WHERE best.BESTELLDATUM "
                + "between '" + von + "' and '" + bis + "' group by best.kund.KNr order by best.kund.KNr asc");
        // Aufruf der Methode Connect; Übergabe des SQL-Statements an die Methode
        // RÜckgabewerte der Methode wird result3 zugewiesen
        result3 = connect("select best.kund.KNr from K_BA WHERE best.BESTELLDATUM "
                + "between '" + von + "' and '" + bis + "' "
                + "group by best.kund.KNr order by best.kund.KNr asc");

        Object rowData[] = new Object[3];
        iterator2 = result2.iterator();
        iterator3 = result3.iterator();
        // result enthält Ergebnisse der SQL-Abfrage
        // diese Ergebnisse werden nun Zeile für Zeile ausgegeben bis keine
        // weiteren in der Liste(result) vorhanden sind)
        for (iterator = result.iterator(); iterator.hasNext();) {
            int KNR = (int) iterator3.next();
            rowData[0] = KNR;

            long BNR = (long) iterator.next();
            rowData[1] = BNR;

            double SumEuro = (double) iterator2.next();
            rowData[2] = SumEuro;
            // Zeile der Tabelle hinzufügen
            model.addRow(rowData);
        }
    }

    // setzen des heutigen Datums in die Datumsauswahlfeldern "von" und "bis"
    private void setDefaultDates(JDateChooser von, JDateChooser bis) {
        Calendar cal = Calendar.getInstance();
        cal.add(Calendar.MONTH, -1);
        Date datelastmonth = cal.getTime();

        von.setDate(datelastmonth);
        bis.setDate(Calendar.getInstance().getTime());
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ReportMainGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ReportMainGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ReportMainGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ReportMainGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new ReportMainGUI().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton buttonBack;
    private javax.swing.JButton buttonBestSelling;
    private javax.swing.JButton buttonCancelVolumen;
    private javax.swing.JButton buttonPrint;
    private javax.swing.JButton buttonShowArticlelist;
    private javax.swing.JButton buttonShowCritStock;
    private javax.swing.JButton buttonShowOpenOrders;
    private javax.swing.JButton buttonShowOrders;
    private javax.swing.JButton buttonVolumenCustomer;
    private javax.swing.JButton buttonWorstSelling;
    private javax.swing.JButton jButtonVolumenOK;
    private com.toedter.calendar.JDateChooser jDateChooserBis;
    private com.toedter.calendar.JDateChooser jDateChooserVon;
    private javax.swing.JLabel jLabelBis;
    private javax.swing.JLabel jLabelVon;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel labelReports;
    private javax.swing.JTable tableAusgabe;
    // End of variables declaration//GEN-END:variables

}
